use halo2_minimal::{pai_circuit::PaiCircuit, aggregator_circuit::AggregatorCircuit};
use halo2_proofs::{
    plonk::{create_proof, keygen_pk, keygen_vk, verify_proof, VerifyingKey},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Blake2bRead, Challenge255},
};
use pasta_curves::pallas::{Affine as EpAffine, Scalar as Fr};
use ff::PrimeField;
use rand_core::OsRng;
use std::sync::Arc;
use tokio::sync::Mutex;
use warp::Filter;
use serde::{Deserialize, Serialize};
use std::error::Error;

// ----------------- JSON Structs -----------------
#[derive(Deserialize)]
struct AgregadoRequest {
    proof_bytes: Vec<u8>,
    sub_public_inputs: Vec<Vec<[u8; 32]>>, // cada Fr como 32 bytes
}

#[derive(Serialize)]
struct AgregadoResponse {
    valido: bool,
}

// ----------------- ConversÃ£o bytes -> Fr -----------------
fn bytes_to_fr(bytes: &[u8; 32]) -> Fr {
    let mut limbs = [0u64; 4];
    for i in 0..4 {
        limbs[i] = u64::from_le_bytes(bytes[i * 8..(i + 1) * 8].try_into().unwrap());
    }
    Fr::from_raw(limbs)
}

// ----------------- VerificaÃ§Ã£o privada -----------------
async fn verificar_agregado(
    proof_bytes: Vec<u8>,
    sub_public_inputs: Vec<Vec<Fr>>,
    vk_agg: &VerifyingKey<EpAffine>,
    params: &Params<EpAffine>,
) -> Result<bool, warp::Rejection> {
    // Concatena cada vetor de inputs para formar &[&[Fr]]
    let instances: Vec<&[Fr]> = sub_public_inputs.iter().map(|v| v.as_slice()).collect();

    let mut transcript = Blake2bRead::<_, _, Challenge255<EpAffine>>::init(&proof_bytes[..]);

    match verify_proof(params, vk_agg, &[&instances], &mut transcript) {
        Ok(_) => Ok(true),
        Err(_) => Ok(false),
    }
}

// ----------------- Handler Warp -----------------
async fn rollup_verifica(req: AgregadoRequest, state: Arc<Mutex<VerifyingKey<EpAffine>>>) -> Result<AgregadoResponse, warp::Rejection> {
    let vk_agg = { let guard = state.lock().await; guard.clone() };
    let params = Params::<EpAffine>::new(16);

    // Converte bytes -> Fr
    let sub_public_inputs: Vec<Vec<Fr>> = req.sub_public_inputs.iter()
        .map(|pair_bytes| pair_bytes.iter().map(|b| bytes_to_fr(b)).collect())
        .collect();

    let valido = verificar_agregado(req.proof_bytes, sub_public_inputs, &vk_agg, &params).await?;
    Ok(AgregadoResponse { valido })
}

// ----------------- Main -----------------
#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Cria VK dummy do AggregatorCircuit (igual ao que serÃ¡ usado para gerar provas)
    let params = Params::<EpAffine>::new(16);
    let dummy_agg = AggregatorCircuit {
        sub_proofs: vec![],
        sub_public_inputs: vec![],
        sub_vks: vec![],
        params: params.clone(),
    };
    let vk_agg = keygen_vk(&params, &dummy_agg)?;
    let vk_state = Arc::new(Mutex::new(vk_agg));

    let rollup_route = warp::post()
        .and(warp::path("rollup_verifica"))
        .and(warp::body::json())
        .and(warp::any().map(move || Arc::clone(&vk_state)))
        .and_then(rollup_verifica);

    println!("ðŸš€ Rollup rodando em http://127.0.0.1:3030");
    warp::serve(rollup_route).run(([127, 0, 0, 1], 3030)).await;

    Ok(())
}
