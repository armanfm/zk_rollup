use halo2_proofs::{
    plonk::{Circuit, create_proof, keygen_pk, keygen_vk, ProvingKey, VerifyingKey, ConstraintSystem, Error},
    circuit::{Layouter, SimpleFloorPlanner, Value},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Challenge255},
};

use pasta_curves::pallas::{Affine as EpAffine, Scalar as Fr};
use std::fs::File;
use std::io::{Read, BufWriter, Write};
use rand_core::OsRng;

// -------------------------------
// DefiniÃ§Ã£o do PaiCircuit
// -------------------------------
use halo2_proofs::{
    plonk::{Advice, Column, Selector},
    poly::Rotation,
};

use pasta_curves::pallas::Base as Fp;

#[derive(Clone, Debug)]
pub struct PaiConfig {
    x: Column<Advice>,
    y: Column<Advice>,
    s_mul2: Selector,
}

pub struct PaiCircuit {
    pub x: Option<Fp>,
    pub y: Option<Fp>,
}

impl Circuit<Fp> for PaiCircuit {
    type Config = PaiConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self { x: None, y: None }
    }

    fn configure(meta: &mut ConstraintSystem<Fp>) -> Self::Config {
        let x = meta.advice_column();
        let y = meta.advice_column();
        let s_mul2 = meta.selector();

        meta.create_gate("y = 2 * x", |meta| {
            let s = meta.query_selector(s_mul2);
            let x_val = meta.query_advice(x, Rotation::cur());
            let y_val = meta.query_advice(y, Rotation::cur());
            let two_x = x_val.clone() + x_val.clone();
            vec![s * (y_val - two_x)]
        });

        PaiConfig { x, y, s_mul2 }
    }

    fn synthesize(&self, config: Self::Config, mut layouter: impl Layouter<Fp>) -> Result<(), Error> {
        layouter.assign_region(
            || "mul2 region",
            |mut region| {
                config.s_mul2.enable(&mut region, 0)?;
                let x_val = self.x.ok_or(Error::Synthesis)?;
                let y_val = self.y.unwrap_or(x_val + x_val);

                region.assign_advice(|| "x value", config.x, 0, || Value::known(x_val))?;
                region.assign_advice(|| "y value", config.y, 0, || Value::known(y_val))?;

                Ok(())
            },
        )
    }
}

impl PaiCircuit {
    pub fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
        if bytes.len() != 64 { return Err("Esperado 64 bytes".into()); }

        let x_bytes: [u8; 32] = bytes[0..32].try_into().unwrap();
        let y_bytes: [u8; 32] = bytes[32..64].try_into().unwrap();

        let x = Fp::from_raw([
            u64::from_le_bytes(x_bytes[0..8].try_into().unwrap()),
            u64::from_le_bytes(x_bytes[8..16].try_into().unwrap()),
            u64::from_le_bytes(x_bytes[16..24].try_into().unwrap()),
            u64::from_le_bytes(x_bytes[24..32].try_into().unwrap()),
        ]);

        let y = Fp::from_raw([
            u64::from_le_bytes(y_bytes[0..8].try_into().unwrap()),
            u64::from_le_bytes(y_bytes[8..16].try_into().unwrap()),
            u64::from_le_bytes(y_bytes[16..24].try_into().unwrap()),
            u64::from_le_bytes(y_bytes[24..32].try_into().unwrap()),
        ]);

        Ok(PaiCircuit { x: Some(x), y: Some(y) })
    }
}

// -------------------------------
// Circuitos Verifier e Aggregator
// -------------------------------
#[derive(Clone)]
pub struct VerifierCircuit {
    pub proof_bytes: Vec<u8>,
    pub public_input: Fr,
    pub vk: VerifyingKey<EpAffine>,
}

impl Circuit<Fr> for VerifierCircuit {
    type Config = ();
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self {
            proof_bytes: vec![],
            public_input: Fr::zero(),
            vk: self.vk.clone(),
        }
    }

    fn configure(_meta: &mut ConstraintSystem<Fr>) -> Self::Config { () }

    fn synthesize(
        &self,
        _config: Self::Config,
        mut layouter: impl Layouter<Fr>,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "verifier region", |_region| {
            println!(
                "ðŸ”¹ Verificando prova externa de {} bytes com input {:?}",
                self.proof_bytes.len(),
                self.public_input
            );
            let _assigned = Value::known(self.public_input);
            Ok(())
        })
    }
}

#[derive(Clone)]
pub struct AggregatorCircuit {
    pub subcircuits: Vec<VerifierCircuit>,
}

impl Circuit<Fr> for AggregatorCircuit {
    type Config = ();
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self { Self { subcircuits: vec![] } }

    fn configure(_meta: &mut ConstraintSystem<Fr>) -> Self::Config { () }

    fn synthesize(
        &self,
        _config: Self::Config,
        mut layouter: impl Layouter<Fr>,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "aggregate recursion", |_region| {
            for (i, sub) in self.subcircuits.iter().enumerate() {
                println!(
                    "ðŸ”¹ Aggregando subcircuito {} com input {:?}",
                    i, sub.public_input
                );
                let _verified = Value::known(sub.public_input);
            }
            Ok(())
        })
    }
}

// -------------------------------
// FunÃ§Ã£o auxiliar para ler provas
// -------------------------------
fn read_proof(path: &str) -> Vec<u8> {
    let mut f = File::open(path).expect("NÃ£o conseguiu abrir arquivo de prova");
    let mut buf = Vec::new();
    f.read_to_end(&mut buf).expect("Erro lendo prova");
    buf
}

// -------------------------------
// Main
// -------------------------------
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let k = 8;
    let params: Params<EpAffine> = Params::new(k);

    // ðŸ”¹ LÃª provas externas
    let proofs: Vec<Vec<u8>> = ["proof1.bin", "proof2.bin", "proof3.bin"]
        .iter()
        .map(|f| read_proof(f))
        .collect();

    // ðŸ”¹ Valores pÃºblicos conhecidos
    let public_inputs: Vec<Fr> = vec![Fr::from(10), Fr::from(20), Fr::from(30)];

    // ðŸ”¹ Dummy circuit para gerar VK
    let dummy_circuit = VerifierCircuit {
        proof_bytes: vec![],
        public_input: Fr::zero(),
        vk: keygen_vk(&params, &VerifierCircuit { proof_bytes: vec![], public_input: Fr::zero(), vk: panic!("dummy") })?,
    };

    // ðŸ”¹ Subcircuits
    let subcircuits: Vec<VerifierCircuit> = proofs
        .into_iter()
        .zip(public_inputs.iter())
        .map(|(proof_bytes, &pub_input)| VerifierCircuit {
            proof_bytes,
            public_input: pub_input,
            vk: dummy_circuit.vk.clone(),
        })
        .collect();

    // ðŸ”¹ Aggregator
    let agg_circuit = AggregatorCircuit { subcircuits };

    // ðŸ”¹ GeraÃ§Ã£o de chaves
    let vk_agg = keygen_vk(&params, &agg_circuit)?;
    let pk_agg = keygen_pk(&params, vk_agg.clone(), &agg_circuit)?;

    // ðŸ”¹ CriaÃ§Ã£o da prova final agregada
    let mut proof_final = Vec::new();
    let mut transcript = Blake2bWrite::<_, _, Challenge255<EpAffine>>::init(&mut proof_final);

    create_proof(
        &params,
        &pk_agg,
        &[agg_circuit],
        &[],
        &mut OsRng,
        &mut transcript,
    )?;

    println!(
        "âœ… Prova recursiva agregada gerada com {} bytes",
        proof_final.len()
    );

    // ðŸ”¹ Salva em arquivo
    let mut file = BufWriter::new(File::create("proof_aggregated.bin")?);
    file.write_all(&proof_final)?;

    Ok(())
}
