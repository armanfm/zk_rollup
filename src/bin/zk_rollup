use warp::Filter;
use serde::{Deserialize, Serialize};
use halo2_proofs::{
    plonk::{create_proof, keygen_pk, keygen_vk, ProvingKey, VerifyingKey},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Challenge255},
};
use pasta_curves::{vesta::Base as Fq, pallas::Affine as EpAffine};
use rand::thread_rng;
use std::sync::{Arc, Mutex};
use std::fs;
use pasta_curves::group::ff::PrimeField;
use anyhow::Result;
use halo2_minimal::{AggregatorCircuit, MyFqCircuit};

// üîπ Adicionado para envio HTTP
use reqwest::Client;

// --------------------
// Custom Warp Error
// --------------------
#[derive(Debug)]
struct CustomError(String);
impl warp::reject::Reject for CustomError {}

// --------------------
// Request / Response
// --------------------
#[derive(Deserialize)]
struct AggregatorRequest {
    sub_inputs: Vec<[u8; 32]>, // recebemos bytes, convertemos para Fq depois
}

#[derive(Serialize)]
struct ProofResponse {
    proof: Vec<u8>,
}

// --------------------
// Estado do agregador
// --------------------
struct ProverState {
    pk: Arc<ProvingKey<EpAffine>>,
    vk: Arc<VerifyingKey<EpAffine>>,
    proofs: Vec<Vec<u8>>,
    count: usize,
}

// --------------------
// Gera prova recursiva usando PK do agregador
// --------------------
fn generate_recursive_proof(
    pk: &ProvingKey<EpAffine>,
    circuit: AggregatorCircuit,
    params: &Params<EpAffine>,
) -> Result<Vec<u8>> {
    println!("üßæ Criando prova agregada real...");

    let mut proof_bytes = Vec::new();
    {
        let mut transcript = Blake2bWrite::<_, _, Challenge255<EpAffine>>::init(&mut proof_bytes);
        let mut rng = thread_rng();
        println!("üßæ Gerando prova real com Halo2...");
        create_proof(
            params,
            pk,
            &[circuit],
            &[&[]],  // inst√¢ncias externas vazias
            &mut rng,
            &mut transcript,
        )?;
    }

    println!("‚úÖ Prova agregada criada, tamanho: {} bytes", proof_bytes.len());
    Ok(proof_bytes)
}

// --------------------
// Fluxo principal de agrega√ß√£o
// --------------------
async fn aggregate_flow(
    requests: Vec<AggregatorRequest>,
    state: Arc<Mutex<ProverState>>,
    k: u32,
) -> Result<Vec<u8>, warp::Rejection> {
    println!("üì• Recebidas {} subprovas", requests.len());

    let params: Params<EpAffine> = Params::new(k);

    // Converte os bytes recebidos para Fq
    let sub_public_inputs: Vec<Vec<Fq>> = requests
        .iter()
        .map(|req| {
            req.sub_inputs
                .iter()
                .map(|arr| Fq::from_repr_vartime(*arr).expect("bytes inv√°lido para Fq"))
                .collect::<Vec<Fq>>()
        })
        .collect();

    // Fake proofs tempor√°rias (s√≥ para exemplo; aqui voc√™ pode substituir pelo real)
    let sub_proofs: Vec<Vec<u8>> = requests.iter().map(|_| vec![0u8; 64]).collect();

    let (pk_arc, vk_arc) = {
        let guard = state.lock().unwrap();
        (guard.pk.clone(), guard.vk.clone())
    };

    let aggregator_circuit = AggregatorCircuit {
        sub_proofs,
        sub_public_inputs: sub_public_inputs.clone(),
        sub_vks: vec![(*vk_arc).clone(); sub_public_inputs.len()],
        params: params.clone(),
    };

    let proof_bytes = generate_recursive_proof(&*pk_arc, aggregator_circuit, &params)
        .map_err(|e| warp::reject::custom(CustomError(format!("{:?}", e))))?;

    {
        let mut guard = state.lock().unwrap();
        guard.proofs.push(proof_bytes.clone());
        guard.count += 1;
    }

    fs::write("proof_recursive.bin", &proof_bytes)
        .map_err(|e| warp::reject::custom(CustomError(format!("{:?}", e))))?;

    println!("‚úÖ Prova recursiva gerada e salva! Bytes: {}", proof_bytes.len());

    // üîπ Envia automaticamente ao servidor Semaphore (porta 3030)
    tokio::spawn({
        let proof_to_send = proof_bytes.clone();
        async move {
            let client = Client::new();
            let url = "http://127.0.0.1:3030/submit_proof";
            println!("üöÄ Enviando prova recursiva ao Semaphore: {}", url);
            match client
                .post(url)
                .body(proof_to_send)
                .send()
                .await
            {
                Ok(res) => println!("‚úÖ [BG] Semaphore respondeu com status: {}", res.status()),
                Err(e) => eprintln!("‚ùå Erro ao enviar ao Semaphore: {:?}", e),
            }
        }
    });

    Ok(proof_bytes)
}

// --------------------
// Warp Server
// --------------------
#[tokio::main]
async fn main() -> Result<()> {
    let k = 8;
    let params: Params<EpAffine> = Params::new(k);

    let dummy_value = Fq::from_raw([0, 0, 0, 0]);
    let dummy_circuit = MyFqCircuit {
        x_fq: Some(dummy_value),
        y_fq: Some(dummy_value),
    };

    println!("‚öôÔ∏è Gerando VK e PK do agregador...");
    let vk = keygen_vk(&params, &dummy_circuit)?;
    let pk = keygen_pk(&params, vk.clone(), &dummy_circuit)?;
    println!("‚úÖ PK e VK do agregador gerados com sucesso.");

    let state: Arc<Mutex<ProverState>> = Arc::new(Mutex::new(ProverState {
        pk: Arc::new(pk),
        vk: Arc::new(vk),
        proofs: Vec::new(),
        count: 0,
    }));

    let state_filter = warp::any().map(move || Arc::clone(&state));

    let aggregate_route = warp::path("aggregate")
        .and(warp::post())
        .and(warp::body::json::<Vec<AggregatorRequest>>())
        .and(state_filter.clone())
        .and_then(move |requests, state| {
            let k_copy = k;
            async move {
                match aggregate_flow(requests, state, k_copy).await {
                    Ok(proof_bytes) => Ok::<_, warp::Rejection>(warp::reply::json(&ProofResponse {
                        proof: proof_bytes,
                    })),
                    Err(e) => Err(e),
                }
            }
        });

    let status_route = warp::path::end().map(|| {
        warp::reply::json(&serde_json::json!({
            "status": "ok",
            "message": "Servidor agregador recursivo rodando e conectado ao Semaphore (3030)"
        }))
    });

    let routes = status_route.or(aggregate_route);

    println!("üöÄ Servidor rodando em http://0.0.0.0:8082");
    warp::serve(routes).run(([0, 0, 0, 0], 8082)).await;

    Ok(())
}
