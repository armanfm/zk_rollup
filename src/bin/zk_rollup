use warp::Filter;
use serde::{Deserialize, Serialize};
use halo2_proofs::{
    plonk::{create_proof, keygen_pk, keygen_vk, SingleVerifier, verify_proof},
    poly::commitment::Params,
    dev::MockProver,
    transcript::{Blake2bWrite, Blake2bRead, Challenge255},
};
use pasta_curves::{vesta::Base as Fq, pallas::Affine as EpAffine};
use pasta_curves::group::ff::PrimeField;
use rand_core::OsRng;
use std::convert::TryInto;
use std::fs;

// --- Importa direto dos m√≥dulos da crate ---
 use halo2_minimal::{MyFq, FqOp, AggregatorCircuit};

// --- Estruturas de request e response ---
#[derive(Deserialize)]
struct AggregatorRequest {
    proof_bytes: Vec<u8>,
    sub_inputs: Vec<Vec<u8>>, // Cada sub_input em Fq, 32 bytes
}

#[derive(Serialize)]
struct AggregatorResponse {
    message: String,
    proof_size: usize,
}

// --- Converte bytes para Fq ---
fn bytes_to_fq(bytes: &[u8]) -> Fq {
    let arr: [u8; 32] = bytes.try_into().expect("Cada Fq deve ter 32 bytes");
    Fq::from_repr(arr).expect("Fq inv√°lido")
}

// --- Fun√ß√£o de agrega√ß√£o ---
async fn aggregate_flow_from_json(requests: Vec<AggregatorRequest>) -> Result<String, String> {
    println!("üì• Recebidas {} provas do prover", requests.len());

    let k = 8;
    let params: Params<EpAffine> = Params::new(k);

    let mut proofs_bytes = Vec::new();
    let mut sub_inputs_fq = Vec::new();
    let mut sub_vks = Vec::new();

    for (i, req) in requests.iter().enumerate() {
        proofs_bytes.push(req.proof_bytes.clone());

        // Converte inputs para Fq
        let inputs_fq: Vec<Fq> = req.sub_inputs.iter().map(|b| bytes_to_fq(b)).collect();
        sub_inputs_fq.push(inputs_fq.clone());

        // Cria um subcircuito MyFq simples s√≥ para gerar VK
        let mut ops = Vec::new();
        for pair in inputs_fq.windows(2) {
            ops.push(FqOp::Add(pair[0], pair[1])); // Exemplo: opera√ß√£o de add
        }
        let sub_circuit = MyFq::new(ops);
        let vk_sub = keygen_vk(&params, &sub_circuit).map_err(|e| e.to_string())?;
        sub_vks.push(vk_sub);

        println!("üîπ Processando prova #{}", i);
        println!("   - Sub-inputs Fq: {:?}", inputs_fq);
    }

    // --- Construir circuito agregador ---
    let agg_circuit = AggregatorCircuit {
        sub_proofs: proofs_bytes,
        sub_public_inputs: sub_inputs_fq,
        sub_vks,
        params: params.clone(),
    };

    // --- PK/VK do agregador ---
    println!("üîë Gerando PK/VK do circuito agregador...");
    let vk_agg = keygen_vk(&params, &agg_circuit).map_err(|e| e.to_string())?;
    let pk_agg = keygen_pk(&params, vk_agg.clone(), &agg_circuit).map_err(|e| e.to_string())?;
    println!("‚úÖ PK/VK gerados");

    // --- MockProver para checagem ---
    let prover = MockProver::run(k, &agg_circuit, vec![]).map_err(|e| e.to_string())?;
    prover.assert_satisfied();

    // --- Cria prova agregada ---
    println!("üõ†Ô∏è Gerando prova agregada...");
    let mut proof_final = Vec::new();
    let mut transcript = Blake2bWrite::<_, _, Challenge255<EpAffine>>::init(&mut proof_final);
    create_proof(&params, &pk_agg, &[agg_circuit], &[], &mut OsRng, &mut transcript)
        .map_err(|e| e.to_string())?;
    println!("‚úÖ Prova agregada gerada com {} bytes", proof_final.len());

    // --- Verifica prova agregada ---
    let mut transcript_read = Blake2bRead::<_, _, Challenge255<EpAffine>>::init(&proof_final[..]);
    let strategy = SingleVerifier::new(&params);
    verify_proof(&params, &vk_agg, strategy, &[], &mut transcript_read)
        .map_err(|e| e.to_string())?;
    println!("‚úÖ Prova agregada verificada com sucesso!");

    fs::write("proof_aggregated.bin", &proof_final).map_err(|e| e.to_string())?;
    println!("üíæ Prova agregada salva em proof_aggregated.bin");

    Ok(format!("Prova agregada gerada e verificada! Bytes: {}", proof_final.len()))
}

// --- Warp server ---
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let aggregate_route = warp::path("aggregate")
        .and(warp::post())
        .and(warp::body::json::<Vec<AggregatorRequest>>())
        .and_then(|requests: Vec<AggregatorRequest>| async move {
            match aggregate_flow_from_json(requests).await {
                Ok(msg) => Ok::<_, warp::Rejection>(warp::reply::json(&AggregatorResponse {
                    message: msg.clone(),
                    proof_size: msg.len(),
                })),
                Err(e) => Ok::<_, warp::Rejection>(warp::reply::json(&AggregatorResponse {
                    message: format!("Erro: {}", e),
                    proof_size: 0,
                })),
            }
        });

    let status_route = warp::path::end().map(|| warp::reply::json(&serde_json::json!({
        "status": "ok",
        "message": "Servidor agregador rodando"
    })));

    let routes = status_route.or(aggregate_route);

    println!("üöÄ Agregador rodando em http://0.0.0.0:8082");
    warp::serve(routes).run(([0, 0, 0, 0], 8082)).await;

    Ok(())
}
