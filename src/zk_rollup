use halo2_proofs::{
    plonk::{Circuit, ConstraintSystem, Error, create_proof, keygen_pk, keygen_vk, ProvingKey, VerifyingKey},
    circuit::{Layouter, SimpleFloorPlanner, Value},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Challenge255},
};
use pasta_curves::pallas::{Affine as EpAffine, Scalar as Fr};
use std::fs::File;
use std::io::{Read, BufWriter, Write};
use rand_core::OsRng;

/// Circuito de VerificaÃ§Ã£o de Prova Externa
#[derive(Clone)]
pub struct VerifierCircuit {
    pub proof_bytes: Vec<u8>,
    pub public_input: Fr,
}

impl Circuit<Fr> for VerifierCircuit {
    type Config = ();
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self { proof_bytes: vec![], public_input: Fr::zero() }
    }

    fn configure(_meta: &mut ConstraintSystem<Fr>) -> Self::Config { () }

    fn synthesize(
        &self,
        _config: Self::Config,
        mut layouter: impl Layouter<Fr>,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "verifier dummy", |mut region| {
            println!("ðŸ”¹ Verificando prova interna: {:?}", self.public_input);
            let _ = Value::known(self.public_input);
            Ok(())
        })
    }
}

/// Circuito Agregador Recursivo
#[derive(Clone)]
pub struct AggregatorCircuit {
    pub subcircuits: Vec<VerifierCircuit>,
}

impl Circuit<Fr> for AggregatorCircuit {
    type Config = ();
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self { subcircuits: vec![] }
    }

    fn configure(_meta: &mut ConstraintSystem<Fr>) -> Self::Config { () }

    fn synthesize(
        &self,
        _config: Self::Config,
        mut layouter: impl Layouter<Fr>,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "aggregate recursion", |mut region| {
            for (i, sub) in self.subcircuits.iter().enumerate() {
                println!("ðŸ”¹ Aggregando subcircuito {} com input {:?}", i, sub.public_input);
                let _ = Value::known(sub.public_input);
            }
            Ok(())
        })
    }
}

fn read_proof(path: &str) -> Vec<u8> {
    let mut f = File::open(path).expect("NÃ£o conseguiu abrir arquivo de prova");
    let mut buf = Vec::new();
    f.read_to_end(&mut buf).expect("Erro lendo prova");
    buf
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let k = 8;
    let params: Params<EpAffine> = Params::new(k);

    // LÃª provas externas
    let proofs: Vec<Vec<u8>> = ["proof1.bin", "proof2.bin", "proof3.bin"]
        .iter().map(|f| read_proof(f)).collect();

    // Define valores pÃºblicos conhecidos
    let public_inputs: Vec<Fr> = vec![Fr::from(10), Fr::from(20), Fr::from(30)];

    // Cria subcircuits para cada prova
    let subcircuits: Vec<VerifierCircuit> = proofs.into_iter()
        .zip(public_inputs.iter())
        .map(|(proof_bytes, &pub_input)| VerifierCircuit { proof_bytes, public_input: pub_input })
        .collect();

    // Circuito agregador recursivo
    let agg_circuit = AggregatorCircuit { subcircuits };

    // GeraÃ§Ã£o de chaves
    let vk_agg = keygen_vk(&params, &agg_circuit)?;
    let pk_agg = keygen_pk(&params, vk_agg.clone(), &agg_circuit)?;

    // Prova final
    let mut proof_final = Vec::new();
    let mut transcript = Blake2bWrite::<_, _, Challenge255<EpAffine>>::init(&mut proof_final);

    create_proof(&params, &pk_agg, &[agg_circuit], &[], &mut OsRng, &mut transcript)?;

    println!("âœ… Prova recursiva agregada gerada com {} bytes", proof_final.len());

    let mut file = BufWriter::new(File::create("proof_aggregated.bin")?);
    file.write_all(&proof_final)?;

    Ok(())
}
