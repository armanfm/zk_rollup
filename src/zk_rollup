use halo2_proofs::{
    plonk::{Circuit, ConstraintSystem, Error, create_proof, keygen_pk, keygen_vk, ProvingKey, VerifyingKey},
    circuit::{Layouter, SimpleFloorPlanner, Value},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Challenge255},
};
use pasta_curves::pallas::{Affine as EpAffine, Scalar as Fr};
use std::fs::File;
use std::io::{Read, BufWriter, Write};
use rand_core::OsRng;

/// -------------------------------
/// Circuito que representa a verificaÃ§Ã£o de uma prova externa
/// -------------------------------
#[derive(Clone)]
pub struct VerifierCircuit {
    pub proof_bytes: Vec<u8>,
    pub public_input: Fr,
    pub vk: VerifyingKey<EpAffine>,
}

impl Circuit<Fr> for VerifierCircuit {
    type Config = ();
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self { proof_bytes: vec![], public_input: Fr::zero(), vk: self.vk.clone() }
    }

    fn configure(_meta: &mut ConstraintSystem<Fr>) -> Self::Config { () }

    fn synthesize(
        &self,
        _config: Self::Config,
        mut layouter: impl Layouter<Fr>,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "verifier region", |mut region| {
            // ðŸ”¹ Aqui vai o gadget que realmente verifica a prova
            println!("ðŸ”¹ Verificando prova externa com input {:?}", self.public_input);

            // Placeholder: cÃ©lulas que representam a verificaÃ§Ã£o
            let _assigned_input = Value::known(self.public_input);

            Ok(())
        })
    }
}

/// -------------------------------
/// Circuito agregador que valida vÃ¡rias provas externas
/// -------------------------------
#[derive(Clone)]
pub struct AggregatorCircuit {
    pub subcircuits: Vec<VerifierCircuit>,
}

impl Circuit<Fr> for AggregatorCircuit {
    type Config = ();
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self { subcircuits: vec![] }
    }

    fn configure(_meta: &mut ConstraintSystem<Fr>) -> Self::Config { () }

    fn synthesize(
        &self,
        _config: Self::Config,
        mut layouter: impl Layouter<Fr>,
    ) -> Result<(), Error> {
        layouter.assign_region(|| "aggregate recursion", |mut region| {
            for (i, sub) in self.subcircuits.iter().enumerate() {
                println!("ðŸ”¹ Aggregando subcircuito {} com input {:?}", i, sub.public_input);
                // Placeholder: aqui vocÃª usaria o gadget de verificaÃ§Ã£o de prova real
                let _verified = Value::known(sub.public_input);
            }
            Ok(())
        })
    }
}

/// -------------------------------
/// FunÃ§Ã£o auxiliar para ler provas de arquivos
/// -------------------------------
fn read_proof(path: &str) -> Vec<u8> {
    let mut f = File::open(path).expect("NÃ£o conseguiu abrir arquivo de prova");
    let mut buf = Vec::new();
    f.read_to_end(&mut buf).expect("Erro lendo prova");
    buf
}

/// -------------------------------
/// Main: gera provas agregadas recursivas
/// -------------------------------
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let k = 8;
    let params: Params<EpAffine> = Params::new(k);

    // ðŸ”¹ LÃª provas externas
    let proofs: Vec<Vec<u8>> = ["proof1.bin", "proof2.bin", "proof3.bin"]
        .iter().map(|f| read_proof(f)).collect();

    // ðŸ”¹ Valores pÃºblicos conhecidos
    let public_inputs: Vec<Fr> = vec![Fr::from(10), Fr::from(20), Fr::from(30)];

    // ðŸ”¹ Dummy circuit para gerar VKs de exemplo (substituir por VKs reais)
    let dummy_circuit = VerifierCircuit { proof_bytes: vec![], public_input: Fr::zero(), vk: keygen_vk(&params, &VerifierCircuit { proof_bytes: vec![], public_input: Fr::zero(), vk: panic!("dummy") })? };

    // ðŸ”¹ Cria subcircuits verificadores
    let subcircuits: Vec<VerifierCircuit> = proofs.into_iter()
        .zip(public_inputs.iter())
        .map(|(proof_bytes, &pub_input)| VerifierCircuit { proof_bytes, public_input: pub_input, vk: dummy_circuit.vk.clone() })
        .collect();

    // ðŸ”¹ Circuito agregador recursivo
    let agg_circuit = AggregatorCircuit { subcircuits };

    // ðŸ”¹ GeraÃ§Ã£o de chaves do agregador
    let vk_agg = keygen_vk(&params, &agg_circuit)?;
    let pk_agg = keygen_pk(&params, vk_agg.clone(), &agg_circuit)?;

    // ðŸ”¹ CriaÃ§Ã£o da prova final agregada
    let mut proof_final = Vec::new();
    let mut transcript = Blake2bWrite::<_, _, Challenge255<EpAffine>>::init(&mut proof_final);
    create_proof(&params, &pk_agg, &[agg_circuit], &[], &mut OsRng, &mut transcript)?;

    println!("âœ… Prova recursiva agregada gerada com {} bytes", proof_final.len());

    // ðŸ”¹ Salva em arquivo
    let mut file = BufWriter::new(File::create("proof_aggregated.bin")?);
    file.write_all(&proof_final)?;

    Ok(())
}
