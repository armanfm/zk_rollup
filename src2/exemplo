use halo2_proofs::{
    plonk::{Circuit, create_proof, keygen_pk, keygen_vk},
    poly::commitment::Params,
    transcript::{Blake2bWrite, Challenge255},
};
use pasta_curves::pallas::{Affine as EpAffine, Base as Fp, Scalar as Fr};
use ff::PrimeField; // necessário para to_repr()
use rand_core::OsRng;
use std::fs;
use std::io::Read;

// Seus circuitos
use halo2_minimal::pai_circuit::PaiCircuit;
use halo2_minimal::verifier_circuit::VerifierCircuit;
use halo2_minimal::aggregator_circuit::AggregatorCircuit;

// Função auxiliar para ler provas
fn read_proof(path: &str) -> Vec<u8> {
    fs::read(path).expect("Erro lendo prova")
}

// Converte Fp -> Fr
fn fp_to_fr(fp: Fp) -> Fr {
    let repr = fp.to_repr(); // pega a representação de bytes
    let mut limbs = [0u64; 4];
    for i in 0..4 {
        limbs[i] = u64::from_le_bytes(repr.as_ref()[i * 8..(i + 1) * 8].try_into().unwrap());
    }
    Fr::from_raw(limbs)
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Parâmetros Halo2
    let k = 16;
    let params: Params<EpAffine> = Params::new(k);

    // Caminhos das provas externas
    let proof_paths = ["proof1.bin", "proof2.bin", "proof3.bin"];

    // Ler provas e inputs públicos
    let mut proofs_bytes = vec![];
    let mut sub_public_inputs: Vec<Vec<Fr>> = vec![];

    for path in &proof_paths {
        let proof = read_proof(path);
        proofs_bytes.push(proof.clone());

        // Ler 64 bytes de input público
        let mut f = fs::File::open(path)?;
        let mut input_bytes = vec![0u8; 64];
        f.read_exact(&mut input_bytes)?;

        let pai = PaiCircuit::from_bytes(&input_bytes)?;
        let fr_x = fp_to_fr(pai.x.unwrap());
        let fr_y = fp_to_fr(pai.y.unwrap());
        sub_public_inputs.push(vec![fr_x, fr_y]);
    }

    // Gerar VK e PK para AggregatorCircuit
    let dummy_agg = AggregatorCircuit {
        sub_proofs: vec![],
        sub_public_inputs: vec![],
        sub_vks: vec![],
        params: params.clone(),
    };
    let vk_agg = keygen_vk(&params, &dummy_agg)?;
    let pk_agg = keygen_pk(&params, vk_agg.clone(), &dummy_agg)?;

    // Criar subcircuits reais
    let subcircuits: Vec<VerifierCircuit> = proofs_bytes
        .iter()
        .zip(sub_public_inputs.iter())
        .map(|(proof, input_vec)| VerifierCircuit {
            proof_bytes: proof.clone(),
            public_input: input_vec.clone(), // agora passa todo o vetor
            vk: vk_agg.clone(),
            params: params.clone(),          // precisa passar params
        })
        .collect();

    // Criar AggregatorCircuit
    let agg_circuit = AggregatorCircuit {
        sub_proofs: proofs_bytes,
        sub_public_inputs,
        sub_vks: vec![vk_agg.clone(); proof_paths.len()],
        params: params.clone(),
    };

    // Criar prova agregada
    let mut proof_final = Vec::new();
    let mut transcript = Blake2bWrite::<_, _, Challenge255<EpAffine>>::init(&mut proof_final);
    create_proof(&params, &pk_agg, &[agg_circuit], &[], &mut OsRng, &mut transcript)?;

    // Salvar prova
    fs::write("proof_aggregated.bin", &proof_final)?;
    println!("✅ Prova agregada gerada com {} bytes", proof_final.len());

    Ok(())
}
